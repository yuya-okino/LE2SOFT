package ch.idsia.agents.controllers;

import ch.idsia.agents.Agent;
import ch.idsia.benchmark.mario.engine.sprites.Mario;
import ch.idsia.benchmark.mario.environments.Environment;

public class Task2Agent extends BasicMarioAIAgent implements Agent{
	
	//ground[縦][横]
int[][] ground = new int[19][19];
//マリオが走り出した場所のLENGTHを格納する変数
int lengthStartDash;
	
public Task2Agent()
{
    super("Task2Agent"); 
    reset();
}

public boolean[] getAction()
{
	//地形情報を格納する多次元配列を作る
    for(int i=0; i<=18; i++){
    	ground[i] = new int[19];
    }
    for(int r=0; r<=18; r++){
    	for(int c=0; c<=18; c++){
    		ground[r][c] = getReceptiveFieldCellValue(r, c);
    	}
    }
    
    //ログに出力
    for(r=0; r<=18; r++){
    	for(c=0; c<=18; c++){
    		System.out.printf("%5s",ground[r][c]);
    	}
    	System.out.print('\n');
    }
    System.out.print("--------------------------------------------------"+"\n");
    
    //上に上がる段差がある時
    //高さ4のジャンプをする
    if(ground[9][11]!=0 || ground[9][10]!=0 ){
        action[Mario.KEY_JUMP] = isMarioAbleToJump || !isMarioOnGround;
    }  
    
    //下に降りる段差がある時
    if(ground[10][10] == 0 && !isHole(10) && !isHole(11) && !isHole(12) && !isHole(13) && !isHole(14)){
        action[Mario.KEY_JUMP] = isMarioAbleToJump || !isMarioOnGround;
    }  
    
    //穴がある時
   	System.out.print('\n');
	System.out.print(isHole(10));
	if(isHole(10) || isHole(11)){
        action[Mario.KEY_JUMP] = isMarioAbleToJump || !isMarioOnGround;
	}

   
    return action;
}

public void reset()
{
    action = new boolean[Environment.numberOfKeys];
    action[Mario.KEY_RIGHT] = true;
}


public boolean isHole(int i){
	boolean a = true;
	for(int n = 0; n <= 18; n++){
		a = a && (ground[n][i] == 0);
	}
	return a;
}
}
